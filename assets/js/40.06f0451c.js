(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{616:function(p,n,t){"use strict";t.r(n);var s=t(3),_=Object(s.a)({},(function(){var p=this,n=p.$createElement,t=p._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":p.$parent.slotKey}},[t("h4",{attrs:{id:"为什么要用-pnpm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-pnpm"}},[p._v("#")]),p._v(" 为什么要用 pnpm?")]),p._v(" "),t("p",[p._v("pnpm 的优点：")]),p._v(" "),t("ul",[t("li",[p._v("节省磁盘空间")]),p._v(" "),t("li",[p._v("速度快")])]),p._v(" "),t("p",[p._v("使用 pnpm，他的方式是 100 个项目用到一个依赖，他会将不同项目中的版本之间的"),t("strong",[p._v("差异")]),p._v("存储在本地类似中央仓库的样子，这样一个依赖包假设有 50 个文件，两个同依赖但不同版本不会全部修改，只会更改如 1 个文件的形式，比较完美的解决 npm 和 pnpm 的两个缺点")]),p._v(" "),t("ul",[t("li",[p._v("安全性")])]),p._v(" "),t("p",[p._v("npm 安装包的安全性问题，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖，因此会出现这种非法访问的情况。 pnpm 采用的方式是依赖分割 npm 安装一个指定依赖包 express 的 node_module 目录")]),p._v(" "),t("p",[t("strong",[p._v("通过.pnpm 做目录结构依赖树")])]),p._v(" "),t("p",[p._v("所依赖的是不会被展示在根目录的，通过.pnpm 里面的关系树软链到真实的代码目录")]),p._v(" "),t("h4",{attrs:{id:"npm-扁平化、pnpm-不扁平化-不懂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm-扁平化、pnpm-不扁平化-不懂"}},[p._v("#")]),p._v(" npm 扁平化、pnpm 不扁平化 ?不懂")]),p._v(" "),t("p",[p._v("pnpm 在安装时，将每一个包，和它们的依赖放到同一个文件夹中。将依赖提升至和包同一层级。同时，形成与依赖树结构一致的软链接，标注每一个依赖的位置。")]),p._v(" "),t("h4",{attrs:{id:"清除幽灵依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#清除幽灵依赖"}},[p._v("#")]),p._v(" 清除幽灵依赖")])])}),[],!1,null,null,null);n.default=_.exports}}]);