import{_ as o,o as p,c as e,O as n}from"./chunks/framework.ed8d50c3.js";const h=JSON.parse('{"title":"为什么要用 pnpm?","description":"","frontmatter":{},"headers":[],"relativePath":"cs/net/pnpm.md","lastUpdated":1710744848000}'),a={name:"cs/net/pnpm.md"},l=n('<h1 id="为什么要用-pnpm" tabindex="-1">为什么要用 pnpm? <a class="header-anchor" href="#为什么要用-pnpm" aria-label="Permalink to &quot;为什么要用 pnpm?&quot;">​</a></h1><blockquote><p>什么是软链接（符号链接）和硬链接</p></blockquote><ul><li>软链接和硬链接的区别 <ul><li>软链接非常常见，其实我们桌面的<strong>快捷方式</strong>就是软链接，软链接指向的是我们的实际文件的位置，（软链接的文件大小非常小）；实际文件删除，软链接就不可用了。</li><li>硬链接的两个文件互不相干，他们都是共享磁盘中的一篇相同的内存空间，即如果一个文件内容修改，另一个文件中的内容也会同步修改，如果一个文件删除了，另一个文件不会受到影响</li></ul></li></ul><h4 id="pnpm-的优点" tabindex="-1">pnpm 的优点： <a class="header-anchor" href="#pnpm-的优点" aria-label="Permalink to &quot;pnpm 的优点：&quot;">​</a></h4><ul><li><p>节省磁盘空间</p></li><li><p>速度快 使用软硬链接 使用 pnpm，他的方式是 100 个项目用到一个依赖，他会将不同项目中的版本之间的<strong>差异</strong>存储在本地类似中央仓库的样子，这样一个依赖包假设有 50 个文件，两个同依赖但不同版本不会全部修改，只会更改如 1 个文件的形式，比较完美的解决 npm 和 pnpm 的两个缺点 所依赖的是不会被展示在根目录的，通过.pnpm 里面的关系树软链到真实的代码目录</p></li><li><p>安全性 npm 安装包的安全性问题，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖，因此会出现这种非法访问的情况。 pnpm 采用的方式是依赖分割 npm 安装一个指定依赖包 express 的 node_module 目录； 此外，还有路径过长的问题 <strong>通过.pnpm 做目录结构依赖树</strong></p></li><li><p>支持 monorepo</p><blockquote><p>什么是 monorepo</p></blockquote></li></ul><ul><li>Monorepo 的核心观点是所有的项目在一个代码仓库中。单个仓库中管理多个项目,相同版本依赖提升到顶层只安装一次，节省磁盘内存 代码复用高，方便进行代码重构。 构建打包耗时较长:可以通过增量构建，而非全量构建；也可以将串行构建，优化成并行构建。</li><li>如何使用 monorepo? 通过 pnpm 的 pnpm-workspace.yaml 配置 使得外部的 main 可以作为主应用,内部的 web 下可以有 react\\vue 等项目,且相同的依赖会提升到外部的 node_modules 中 执行子模块命令:可以使用 pnpm -F react-demo dev 执行内部子项目中的 script 子模块复用: 添加 common; 在 pnpm-workspace.yaml 配置 common; 执行 pnpm -F main add common;即可使用 common 中的公共方法; (比较 git 的 libcommon 好用,实时添加)</li></ul><h4 id="扁平化" tabindex="-1">扁平化 <a class="header-anchor" href="#扁平化" aria-label="Permalink to &quot;扁平化&quot;">​</a></h4><p>npm1、npm2 采用递归管理，npm3、npm3+、yarn 依赖扁平化管理消除依赖提升。 pnpm 依赖策略：消除依赖提升、规范拓扑结构 pnpm 在安装时，将每一个包，和它们的依赖放到同一个文件夹中。将依赖提升至和包同一层级。同时，形成与依赖树结构一致的软链接，标注每一个依赖的位置。</p><h4 id="清除幽灵依赖" tabindex="-1">清除幽灵依赖 <a class="header-anchor" href="#清除幽灵依赖" aria-label="Permalink to &quot;清除幽灵依赖&quot;">​</a></h4><blockquote><p>什么是幽灵依赖？</p></blockquote><ul><li>未在项目的 package.json 中定义的包。就是幽灵依赖 node 的寻包过程 首先在当前目录下的 node_modules 寻找，找到了就直接使用，找不到就会往上一级的 node_modules 寻找，直到找寻到磁盘根目录的 node_modules 找不到 直接抛出对应错误。 yarn 的这个方式，就是把相同的依赖包进行提升的方式，就会造成幽灵依赖</li></ul>',11),t=[l];function m(r,i,s,c,d,u){return p(),e("div",null,t)}const b=o(a,[["render",m]]);export{h as __pageData,b as default};
