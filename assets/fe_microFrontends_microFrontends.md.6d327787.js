import{_ as i,o as l,c as a,O as e}from"./chunks/framework.ed8d50c3.js";const b=JSON.parse('{"title":"什么是微前端?","description":"","frontmatter":{},"headers":[],"relativePath":"fe/microFrontends/microFrontends.md","lastUpdated":1710918081000}'),o={name:"fe/microFrontends/microFrontends.md"},r=e('<h1 id="什么是微前端" tabindex="-1">什么是微前端? <a class="header-anchor" href="#什么是微前端" aria-label="Permalink to &quot;什么是微前端?&quot;">​</a></h1><h2 id="微前端特性" tabindex="-1">微前端特性 <a class="header-anchor" href="#微前端特性" aria-label="Permalink to &quot;微前端特性&quot;">​</a></h2><ul><li><strong>技术栈无关</strong>   主框架不限制接入应用的技术栈，子应用可自主选择技术栈（vue，react，jq 等）</li><li><strong>独立开发/部署</strong>  各个团队之间仓库独立，单独部署，互不依赖</li><li><strong>增量升级</strong>   当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性</li><li><strong>独立运行时</strong>   微应用之间运行时互不依赖，有独立的状态管理</li></ul><h2 id="微前端方案" tabindex="-1">微前端方案 <a class="header-anchor" href="#微前端方案" aria-label="Permalink to &quot;微前端方案&quot;">​</a></h2><h3 id="iframe-方案" tabindex="-1">iframe 方案 <a class="header-anchor" href="#iframe-方案" aria-label="Permalink to &quot;iframe 方案&quot;">​</a></h3><ul><li><p>特点</p><ol><li>接入比较简单</li><li>隔离非常完美</li></ol></li><li><p>不足</p><ol><li>dom 割裂感严重，弹框只能在 iframe</li><li>通讯非常麻烦,只能靠 postmessage，而且刷新 iframe url 状态丢失</li><li>前进后退按钮无效</li><li>白屏时间太长，对于 SPA 应用来说无法接受</li></ol></li></ul><h3 id="qiankun-方案" tabindex="-1">qiankun 方案 <a class="header-anchor" href="#qiankun-方案" aria-label="Permalink to &quot;qiankun 方案&quot;">​</a></h3><p>qiankun 方案是基于 single-spa 的微前端方案。</p><ul><li><p>特点</p><ol><li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li><li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li><li>做了静态资源预加载能力；</li></ol></li><li><p>不足</p><ol><li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li><li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li><li>无法同时激活多个子应用，也不支持子应用保活；</li><li>无法支持 vite 等 esmodule 脚本运行；</li></ol></li></ul><p>底层原理 js 沙箱使用的是 proxy 进行快照然后用 with(window){} 包裹起来 with 内的 window 其实就是 proxy.window 我们声明变量 var name = &#39;jy&#39; 实际这个变量挂到了 proxy.window 并不是真正的 window css 沙箱原理 第一个就是 shadowDom 隔离 第二个类似于 Vue 的 scoped [data-qiankun-426732]</p><h3 id="micro-app-方案" tabindex="-1">micro-app 方案 <a class="header-anchor" href="#micro-app-方案" aria-label="Permalink to &quot;micro-app 方案&quot;">​</a></h3><p>micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。</p><ul><li><p>特点</p><ol><li>使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；</li><li>复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；</li><li>组件式的 api 更加符合使用习惯，支持子应用保活；</li><li>降低子应用改造的成本，提供静态资源预加载能力；</li></ol></li><li><p>不足</p><ol><li>接入成本较 qiankun 有所降低，但是路由依然存在依赖； （虚拟路由已解决）</li><li>多应用激活后无法保持各子应用的路由状态，刷新后全部丢失； （虚拟路由已解决）</li><li>css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li><li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li><li>对于不支持 webcompnent 的浏览器没有做降级处理；</li></ol></li></ul><h3 id="emp-方案" tabindex="-1">EMP 方案 <a class="header-anchor" href="#emp-方案" aria-label="Permalink to &quot;EMP 方案&quot;">​</a></h3><p>EMP 方案是基于 webpack 5 module federation 的微前端方案。</p><ul><li>特点</li></ul><ol><li>webpack 联邦编译可以保证所有子应用依赖解耦；</li><li>应用间去中心化的调用、共享模块；</li><li>模块远程 ts 支持；</li></ol><ul><li>不足 <ol><li>对 webpack 强依赖，老旧项目不友好；</li><li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li><li>子应用保活、多应用激活无法实现；</li><li>主、子应用的路由可能发生冲突；</li></ol></li></ul><p>底层原理 这个东西有点类似于拆包，也可以叫模块共享，例如 React 有个模块可以共享给 Vue 项目用 Vue2 的组件可以共享给 Vue3 用。</p><h3 id="无界微前端-方案" tabindex="-1">无界微前端 方案 <a class="header-anchor" href="#无界微前端-方案" aria-label="Permalink to &quot;无界微前端 方案&quot;">​</a></h3><p>预览 <a href="https://wujie-micro.github.io/doc/wujie/" target="_blank" rel="noreferrer">demo</a></p><ul><li>特点 <ol><li>接入简单只需要四五行代码</li><li>不需要针对 vite 额外处理</li><li>预加载(requestIdleCallback)</li><li>应用保活机制</li></ol></li><li>不足 <ol><li>隔离 js 使用一个空的 iframe 进行隔离</li><li>子应用 axios 需要自行适配</li><li>iframe 沙箱的 src 设置了主应用的 host，初始化 iframe 的时候需要等待 iframe 的 location.orign 从&#39;about:blank&#39;初始化为主应用的 host，这个采用的计时器去等待的不是很悠亚。</li></ol></li></ul>',22),t=[r];function n(s,c,p,d,u,h){return l(),a("div",null,t)}const f=i(o,[["render",n]]);export{b as __pageData,f as default};
