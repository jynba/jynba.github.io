import{_ as e,o as a,c as s,O as n}from"./chunks/framework.ed8d50c3.js";const A=JSON.parse('{"title":"requestIdleCallback 和 requestAnimationFrame","description":"","frontmatter":{},"headers":[],"relativePath":"fe/microFrontends/rAF_rSC.md","lastUpdated":1715306612000}'),l={name:"fe/microFrontends/rAF_rSC.md"},o=n(`<h1 id="requestidlecallback-和-requestanimationframe" tabindex="-1">requestIdleCallback 和 requestAnimationFrame <a class="header-anchor" href="#requestidlecallback-和-requestanimationframe" aria-label="Permalink to &quot;requestIdleCallback 和 requestAnimationFrame&quot;">​</a></h1><h3 id="页面流畅与-fps" tabindex="-1">页面流畅与 FPS <a class="header-anchor" href="#页面流畅与-fps" aria-label="Permalink to &quot;页面流畅与 FPS&quot;">​</a></h3><p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p><p>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。</p><h3 id="frame" tabindex="-1">Frame <a class="header-anchor" href="#frame" aria-label="Permalink to &quot;Frame&quot;">​</a></h3><p>那么浏览器每一帧都需要完成哪些工作？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16adf75ec9cc962d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="image"></p><p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p><ul><li>处理用户的交互</li><li>JS 解析执行</li><li>帧开始。窗口尺寸变更，页面滚去等的处理</li><li>requestAnimationFrame(rAF)</li><li>布局</li><li>绘制</li></ul><blockquote><p>或者说</p></blockquote><p><strong>一帧内做了什么事呢</strong></p><p>1.处理用户的事件，就是 event 例如 click，input change 等。</p><p>2.执行定时器任务</p><p>3.执行 requestAnimationFrame</p><p>4.执行 dom 的回流与重绘</p><p>5.计算更新图层的绘制指令</p><p>6.绘制指令合并主线程 如果有空余时间会执行 <code>requestidlecallback</code></p><h3 id="requestidlecallback" tabindex="-1">requestIdleCallback <a class="header-anchor" href="#requestidlecallback" aria-label="Permalink to &quot;requestIdleCallback&quot;">​</a></h3><p>上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 <code>requestIdleCallback</code> 里注册的任务。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16adf75ec9c24938~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="image"></p><p>从上图也可看出，和 <strong><code>requestAnimationFrame</code> 每一帧必定会执行不同，<code>requestIdleCallback</code> 是捡浏览器空闲来执行任务。</strong></p><p>如此一来，假如浏览器一直处于非常忙碌的状态，<code>requestIdleCallback</code> 注册的任务有可能永远不会执行。此时可通过设置 <code>timeout</code> （见下面 API 介绍）来保证执行。</p><h4 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h4><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var handle = window.requestIdleCallback(callback[, options])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><p>callback</p><p>：回调，即空闲时需要执行的任务，该回调函数接收一个</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">IdleDeadline</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>对象作为入参。其中</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">IdleDeadline</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>对象包含：</p><ul><li><code>didTimeout</code>，布尔值，表示任务是否超时，结合 <code>timeRemaining</code> 使用。</li><li><code>timeRemaining()</code>，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。</li></ul></li><li><p>options</p><p>：目前 options 只有一个参数</p><ul><li><code>timeout</code>。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。</li></ul></li></ul><blockquote><p><code>IdleDeadline</code>对象参考 MDN:<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FIdleDeadline" target="_blank" rel="noreferrer">developer.mozilla.org/zh-CN/docs/…</a></p></blockquote><h4 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h4><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">requestIdleCallback(myNonEssentialWork, { timeout: 2000 });</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 任务队列</span></span>
<span class="line"><span style="color:#A6ACCD;">const tasks = [</span></span>
<span class="line"><span style="color:#A6ACCD;"> () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">   console.log(&quot;第一个任务&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"> },</span></span>
<span class="line"><span style="color:#A6ACCD;"> () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">   console.log(&quot;第二个任务&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"> },</span></span>
<span class="line"><span style="color:#A6ACCD;"> () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">   console.log(&quot;第三个任务&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"> },</span></span>
<span class="line"><span style="color:#A6ACCD;">];</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function myNonEssentialWork (deadline) {</span></span>
<span class="line"><span style="color:#A6ACCD;"> // 如果帧内有富余的时间，或者超时</span></span>
<span class="line"><span style="color:#A6ACCD;"> while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">   work();</span></span>
<span class="line"><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"> if (tasks.length &gt; 0)</span></span>
<span class="line"><span style="color:#A6ACCD;">   requestIdleCallback(myNonEssentialWork);</span></span>
<span class="line"><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function work () {</span></span>
<span class="line"><span style="color:#A6ACCD;"> tasks.shift()();</span></span>
<span class="line"><span style="color:#A6ACCD;"> console.log(&#39;执行任务&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>超时的情况，其实就是浏览器很忙，没有空闲时间，此时会等待指定的 <code>timeout</code> 那么久再执行，通过入参 <code>dealine</code> 拿到的 <code>didTmieout</code> 会为 <code>true</code>，同时 <code>timeRemaining ()</code> 返回的也是 0。超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长。</p><h4 id="cancelidlecallback" tabindex="-1">cancelIdleCallback <a class="header-anchor" href="#cancelidlecallback" aria-label="Permalink to &quot;cancelIdleCallback&quot;">​</a></h4><p>与 <code>setTimeout</code> 类似，返回一个唯一 id，可通过 <code>cancelIdleCallback</code> 来取消任务。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>一些低优先级的任务可使用 <code>requestIdleCallback</code> 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）。</p><p>因为它发生在一帧的最后，此时页面布局已经完成，<strong>所以不建议在 <code>requestIdleCallback</code> 里再操作 DOM</strong>，这样会导致页面再次重绘。<strong>DOM 操作建议在 rAF 中进行</strong>。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。</p><p><strong>Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 <code>requestIdleCallback</code> 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</strong></p><h3 id="额外补充一下window-requestanimationframe" tabindex="-1">额外补充一下<code>window.requestAnimationFrame</code> <a class="header-anchor" href="#额外补充一下window-requestanimationframe" aria-label="Permalink to &quot;额外补充一下\`window.requestAnimationFrame\`&quot;">​</a></h3><p>在没有 <code>requestAnimationFrame</code> 方法的时候，执行动画，我们可能使用 <code>setTimeout</code> 或 <code>setInterval</code> 来触发视觉变化；但是这种做法的问题是：回调函数执行的时间是不固定的，可能刚好就在末尾，或者直接就不执行了，经常会引起丢帧而导致页面卡顿。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16adf75ec9bf5c8a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="image"></p><p>归根到底发生上面这个问题的原因在于时机，也就是浏览器要知道何时对回调函数进行响应。<strong><code>setTimeout</code> 或 <code>setInterval</code> 是使用定时器来触发回调函数的，而定时器并无法保证能够准确无误的执行，有许多因素会影响它的运行时机，比如说：当有同步代码执行时，会先等同步代码执行完毕，异步队列中没有其他任务，才会轮到自己执行</strong>。并且，我们知道每一次重新渲染的最佳时间大约是 16.6 ms，如果定时器的时间间隔过短，就会造成 <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2013%2F09%2Fcss3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95%2F" target="_blank" rel="noreferrer">过度渲染</a>，增加开销；过长又会延迟渲染，使动画不流畅。</p><p><code>requestAnimationFrame</code> 方法不同与 <code>setTimeout</code> 或 <code>setInterval</code>，它是由系统来决定回调函数的执行时机的，会请求浏览器在下一次重新渲染之前执行回调函数。无论设备的刷新率是多少，<strong><code>requestAnimationFrame</code> 的时间间隔都会紧跟屏幕刷新一次所需要的时间</strong>；例如某一设备的刷新率是 75 Hz，那这时的时间间隔就是 13.3 ms（1 秒 / 75 次）。需要注意的是这个方法虽然能够<strong>保证回调函数在每一帧内只渲染一次</strong>，但是<strong>如果这一帧有太多任务执行，还是会造成卡顿的；因此它只能保证重新渲染的时间间隔最短是屏幕的刷新时间。</strong></p><p><code>requestAnimationFrame</code> 方法的具体说明可以看 <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame" target="_blank" rel="noreferrer">MDN</a> 的相关文档，下面通过一个网页动画的示例来了解一下如何使用。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">复制代码let offsetTop = 0;</span></span>
<span class="line"><span style="color:#A6ACCD;">const div = document.querySelector(&quot;.div&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">const run = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;"> div.style.transform = \`translate3d(0, \${offsetTop += 10}px, 0)\`;</span></span>
<span class="line"><span style="color:#A6ACCD;"> window.requestAnimationFrame(run);</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">run();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果想要实现动画效果，每一次执行回调函数，必须要再次调用 <code>requestAnimationFrame</code> 方法；与 <code>setTimeout</code> 实现动画效果的方式是一样的，只不过不需要设置时间间隔。</p><p>参考：<a href="https://juejin.cn/post/6844903848981577735" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903848981577735</a></p><p>这个跟<code>react</code> 的 <code>fiber</code> 的有什么关系?</p><p>因为 react 也有该机制 但是 react 并没有用 <code>requestidlecallback</code>，说是这个东西经过测试可能会超过 16ms，超过 16ms 绘制就会看起来很卡 所以 react16 是用的 <code>requestAnimationFrame + postMessage</code> 实现的</p><p>那为什么不用<code>setTimeOut\`\` setTimeOut</code> 设置为 0 也会有一个最小毫秒延迟 4ms，所以是用了<code>postMessage</code>，react18 又换成了<code>MessageChannel</code> 实现了队列方式去执行任务。</p><p>参考：<a href="https://juejin.cn/post/7212603829572911159" target="_blank" rel="noreferrer">https://juejin.cn/post/7212603829572911159</a></p>`,48),p=[o];function t(r,c,i,d,m,u){return a(),s("div",null,p)}const C=e(l,[["render",t]]);export{A as __pageData,C as default};
