# 为什么要用 pnpm?

> 什么是软链接（符号链接）和硬链接

- 软链接和硬链接的区别
  - 软链接非常常见，其实我们桌面的**快捷方式**就是软链接，软链接指向的是我们的实际文件的位置，（软链接的文件大小非常小）；实际文件删除，软链接就不可用了。
  - 硬链接的两个文件互不相干，他们都是共享磁盘中的一篇相同的内存空间，即如果一个文件内容修改，另一个文件中的内容也会同步修改，如果一个文件删除了，另一个文件不会受到影响

#### pnpm 的优点：

- 节省磁盘空间
- 速度快
  使用软硬链接
  使用 pnpm，他的方式是 100 个项目用到一个依赖，他会将不同项目中的版本之间的**差异**存储在本地类似中央仓库的样子，这样一个依赖包假设有 50 个文件，两个同依赖但不同版本不会全部修改，只会更改如 1 个文件的形式，比较完美的解决 npm 和 pnpm 的两个缺点
  所依赖的是不会被展示在根目录的，通过.pnpm 里面的关系树软链到真实的代码目录
- 安全性
  npm 安装包的安全性问题，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖，因此会出现这种非法访问的情况。 pnpm 采用的方式是依赖分割 npm 安装一个指定依赖包 express 的 node_module 目录；
  此外，还有路径过长的问题
  **通过.pnpm 做目录结构依赖树**

- 支持 monorepo
  > 什么是 monorepo

* Monorepo 的核心观点是所有的项目在一个代码仓库中。单个仓库中管理多个项目,相同版本依赖提升到顶层只安装一次，节省磁盘内存 代码复用高，方便进行代码重构。
  构建打包耗时较长:可以通过增量构建，而非全量构建；也可以将串行构建，优化成并行构建。
* 如何使用 monorepo?
  通过 pnpm 的 pnpm-workspace.yaml 配置
  使得外部的 main 可以作为主应用,内部的 web 下可以有 react\vue 等项目,且相同的依赖会提升到外部的 node_modules 中
  执行子模块命令:可以使用 pnpm -F react-demo dev 执行内部子项目中的 script
  子模块复用: 添加 common; 在 pnpm-workspace.yaml 配置 common; 执行 pnpm -F main add common;即可使用 common 中的公共方法; (比较 git 的 libcommon 好用,实时添加)

#### 扁平化

npm1、npm2 采用递归管理，npm3、npm3+、yarn 依赖扁平化管理消除依赖提升。
pnpm 依赖策略：消除依赖提升、规范拓扑结构
pnpm 在安装时，将每一个包，和它们的依赖放到同一个文件夹中。将依赖提升至和包同一层级。同时，形成与依赖树结构一致的软链接，标注每一个依赖的位置。

#### 清除幽灵依赖

> 什么是幽灵依赖？

- 未在项目的 package.json 中定义的包。就是幽灵依赖
  node 的寻包过程
  首先在当前目录下的 node_modules 寻找，找到了就直接使用，找不到就会往上一级的 node_modules 寻找，直到找寻到磁盘根目录的 node_modules 找不到 直接抛出对应错误。
  yarn 的这个方式，就是把相同的依赖包进行提升的方式，就会造成幽灵依赖
